(*
 * vim: ft=sml
 *)

%defs (
  fun readerMacro name forms = Sexp.List ((Sexp.sym name)::forms)
  val isKeyword = String.isPrefix ":"
);

%tokens
  (* punctuation *)
  : LParen ("(") | RParen (")")
  | LSquare ("[") | RSquare ("]")
  | LCurly ("{") | RCurly ("}")
  | Quote ("'") | Backtick ("`")
  | Splice ("~@")
  | Tilde ("~")
  | At ("@")
  | Caret ("^")
  | CommentStart (";") | Comment of string | CommentEnd ("\n")
  (* regular program text *)
  | DoubleQuote ("\"")
  | Char of char
  | ID of string
  | Num of int
  | True ("true") | False ("false")
  | Nil ("nil")
;

%keywords True, False, Nil;

%start top;

top
  : form comment? => ( form )
  | comment
  ;

comment : ";" Comment "\n" => ( Sexp.Comment Comment );

form
  : slist
  | vector
  | map
  | atom
  | quote
  | qquote
  | unquote
  | splice
  | deref
  | meta
  ;

slist : "(" form* ")" => ( Sexp.List form ) ;
vector : "[" form* "]" => ( Sexp.Vector form ) ;
map : "{" kvs=(form form)* "}" => ( Sexp.Map kvs ) ;
quote : Quote form => ( readerMacro "quote" [form] ) ;
qquote : Backtick form => ( readerMacro "quasiquote" [form] ) ;
unquote : Tilde form => ( readerMacro "unquote" [form] ) ;
splice : Splice form => ( readerMacro "splice-unquote" [form] ) ;
deref : At form => ( readerMacro "deref" [form] ) ;
meta : Caret map form => ( readerMacro "with-meta" [form, map] );

atom
  : Num => ( Sexp.Num Num )
  | Nil => ( Sexp.Nil )
  | True => ( Sexp.Bool true ) | False => ( Sexp.Bool false )
  | astring
  | %try keyword
  | %try symbol
  ;

astring : DoubleQuote Char* DoubleQuote => ( Sexp.String (implode Char) ) ;
symbol : ID %where ( not (isKeyword ID) ) => ( Sexp.sym ID ) ;
keyword : ID %where ( isKeyword ID ) => ( Sexp.kw (String.extract (ID, 1, NONE)) );
