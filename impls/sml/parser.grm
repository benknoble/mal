(*
 * vim: ft=sml
 *)

%defs (
  fun readerMacro name form = Sexp.List [(Sexp.sym name), form]
);

%tokens
  (* punctuation *)
  : LParen ("(") | RParen (")")
  | LSquare ("[") | RSquare ("]")
  | LCurly ("{") | RCurly ("}")
  | Quote ("'") | Backtick ("`")
  | Splice ("~@")
  | Tilde ("~")
  | At ("@")
  | Caret ("^")
  (* regular program text *)
  | DoubleQuote ("\"")
  | Char of char
  | ID of string
  | Num of int
  | True ("true") | False ("false")
  | Nil ("nil")
;

%keywords True, False, Nil;

%start form;

form
  : "(" form* ")" => ( Sexp.List form )
  | "[" form* "]" => ( Sexp.Vector form )
  | "{" kvs=(form form)* "}" => ( Sexp.Map kvs )
  | atom => ( atom )
  | Quote form => ( readerMacro "quote" form )
  | Backtick form => ( readerMacro "quasiquote" form )
  | Tilde form => ( readerMacro "unquote" form )
  | Splice form => ( readerMacro "splice-unquote" form )
  | At form => ( readerMacro "deref" form )
  ;

atom
  : Num => ( Sexp.Num Num )
  | Nil => ( Sexp.Nil )
  | True => ( Sexp.Bool true ) | False => ( Sexp.Bool false )
  | DoubleQuote Char* DoubleQuote => ( Sexp.String (implode Char) )
  | ID => ( case (explode ID)
              of #":" :: tl => Sexp.kw (implode tl)
               | _ => Sexp.sym ID )
  ;
